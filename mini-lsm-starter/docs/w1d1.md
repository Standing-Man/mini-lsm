## Memtables

Q: bytes::Byte VS Arc<[u8]>

A:

1. 内存共享和引用计数
   - `Arc<[u8]>`:  
      - `Arc<[u8]>` 是线程安全的引用计数智能指针
      - 当你使用clone方法克隆时,底层数据不会被复制,仅仅是增加引用计数.
      - 多个`Arc<[u8]>`可以共享同一块内存,当最后一个引用被丢弃时才释放内存
   - bytes::Bytes
      - 底层保存一块内存缓冲区也是[u8]
      - 当克隆`Bytes`并不会复制数据,而是共享相同的内存
      - 当所有`Bytes`实例被丢弃时，底层内存才会释放

   -> 相似点: 共享底层数据 + 克隆轻量级 + 延迟释放
2. 内存切片
    - Arc<[u8]>
      - 直接使用`Arc<[u8]>`切片得到的是普通引用，需要自己管理生命周期。
      - 如果想得到一个新的`Arc<[u8]>`的子片段,需要通过 `Arc::from(&slice)` 重新分配，或者用第三方库做“共享切片”，否则会复制数据。
    - Bytes
      - Bytes支持零拷贝的子切片: `bytes.slice(a..b)`
      - 子切片不会复制内存，只是创建新的 `Bytes` 引用同一块底层内存，同时维护自己的偏移和长度

Q: 为什么会将LsmStorageState封装成`state: Arc<RwLock<Arc<LsmStorageState>>>`?

A: 以这种方式结构化可以并发和安全地管理LSM Tree的整体状态,主要使用写时复制(Copy and Write, Cow)策略.
- `Arc<LsmStorageState>`可以看作一个不可变的快照(immutable snapshot), 每一个`reader`都可以拷贝一个不可变的`LsmStorageState`. 底层的`LsmStorageState`并没有变化,`reader`线程拷贝之后仅仅是原子性地添加了引用次数.
- `RwLock<Arc<LsmStorageState>>`: 这里使用读写锁来保护指向当前的`LsmStorageState`的指针.
  - **Reader**请求一份读锁,克隆 `Arc<LsmStorageState>`(获取当前快照的独立引用),之后立刻释放读锁,
      ```
      /// state: RwLock<Arc<LsmStorageState>>
      let reader = state.read();
      let state = reader.clone();
      drop(reader);
      // continue to operate the `state`
      ```
   - **Writer**需要修改`LsmStorageState`,
     ```
      // 获得一个Snapshot
      let reader = state.read();
      let state = reader.clone();
      drop(reader);
      let new_state = LsmStorageState {
            memtable: Arc::new(MemTable::create(self.next_sst_id())),
            imm_memtables: old_state.imm_memtables.clone(),
            l0_sstables: old_state.l0_sstables.clone(),
            levels: old_state.levels.clone(),
            sstables: old_state.sstables.clone(),
      };
     ```

Q: 为什么memtable不提供一个`delete`的API?

A: LSM Storage核心思想是顺序写+延迟合并. memtable最终会被flush成SSTable(不可变文件). 如果将memtable中删除一条key的话,那么flush之后的旧SSTable里仍然可能保存这条`key`的历史值,因此,必须要保证读请求时能知道这个key已经删除了
  - 引入墓碑标记(tombstone): 
    - 当前实现时将key岁对应的值为空字符串. 
    - tombstone记录的含义是该key在某一时间戳之后被删除,即使旧SSTable中还有该key,也视为已删除.
    - tombstone会像普通key一样参与flush、compaction。
    - 随着时间推移，系统会做 compaction，把多个 SSTable 合并成新的 SSTable,如果遇到 A -> TOMBSTONE，同时又在更老的 SSTable 中找到 A -> "hello"，就会把它们一起丢弃。


Q: 将所有写操作存储在memtable中而不是只存储键的最新版本，这样做有意义吗？例如，用户将a->1、a->2和a->3放入同一个memtable中。

A: `memtable`储存所有的写操作是有意义的,因为它确保了数据的一致性和持久性,并且便于后续的合并操作。在LSM(Log Storage Merge Tree)中,虽然memtable会储存所有的写操作,但是最终的合并过程会清理掉过时或者重复的版本,只保留每个键的最新的版本.

Q: 我们可能使用其他的数据结构作为memtable吗?那么使用`skiplist`的优缺点?

A: 是的，LSM 中可以使用其他数据结构作为`memtable`，比如红黑树 (Red-Black Tree)、跳表 (SkipList) 或 哈希表 (HashMap)。
跳表的优缺点:
  - 优点:
    - 有序性,跳表自然保持元素的顺序性,支持快速的范围查找和按顺序遍历.
    - 高效的查找和插入: 跳表在插入、删除、查找等操作上的平均时间复杂度为`O(log N)`,相比红黑树实现简单且相似.
    - 易于实现：跳表的实现比平衡树（如红黑树）简单，且不需要复杂的旋转操作。
  - 缺点:
    - 空间开销大：跳表为了实现多层索引结构，会占用更多的内存空间。
    - 性能波动：虽然在大多数情况下跳表表现良好，但在某些极端情况下，跳表的性能可能会比平衡树差，特别是在频繁的删除操作时。


