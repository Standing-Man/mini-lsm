## Memtables

Q: 为什么需要这种设计?
```
type SkipMapRangeIter<'a> =
    crossbeam_skiplist::map::Range<'a, Bytes, (Bound<Bytes>, Bound<Bytes>), Bytes, Bytes>;

#[self_referencing]
pub struct MemTableIterator {
    /// Stores a reference to the skipmap.
    map: Arc<SkipMap<Bytes, Bytes>>,
    /// Stores a skipmap iterator that refers to the lifetime of `MemTableIterator` itself.
    #[borrows(map)]
    #[not_covariant]
    iter: SkipMapRangeIter<'this>,
    /// Stores the current key-value pair.
    item: (Bytes, Bytes),
}
```

A: `map`拥有一个`Arc<SkipMap<Bytes, Bytes>>`, `iter`是一个迭代器 `SkipMapRangeIter<'a>`，它必须引用`map`内部的数据.
iter 的生命周期要依赖 map 的生命周期。但是`iter`是作为`MemTableIterator`的字段储存的,而它需要引用同一个结构体中里面的另一个字段`map`.
这里就出现了自引用问题: 结构体内部的字段相互依赖，Rust编译器在普通场景下无法表达这种关系。
```
struct Bad<'a> {
    map: SkipMap<Bytes, Bytes>,
    iter: Range<'a, Bytes, ...>, // 想引用上面 map 的数据
}
```
因为'a必须要比整个`Bad`活得久,但是`Bad`自己又包含了`map`,于是出现了声明周期的依赖,编译器拒绝.
因此,使用**自引用模式结构体模式**, 通过宏`(#[self_referencing])`来安全地在一个结构体里保存一个字段和另一个字段对前者的借用。
使用`ouroboros`来生成安全的自引用结构体.它会在构造时保证先构造`map`,再用`map`来生成`iter`,并且使用`'this`声明周期来让编译器解释`iter`
引用的正是这个结构体自己内部的数据.


Q: 如何设计`MemTableIterator`?

A: 因为我将`(Bytes::new(), Bytes::new())`作为`iterator`结束标志, 所以当`item`所对应的`key`和`value`同时为空时,
则说明该`iterator`已经结束了.
- 设计`next`函数时, 如果调用iter的next函数未成功获取元素,则说明底层`iterator`已结束,则返回`iterator`结束标志.

